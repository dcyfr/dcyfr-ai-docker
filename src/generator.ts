/**
 * DCYFR AI Docker - Dockerfile & Compose Generator
 *
 * Generates Dockerfiles and docker-compose.yml configurations
 * based on application type and requirements.
 */

import type { DockerBuildConfig, ComposeConfig, GenerateOptions } from './types.js';
import { DockerBuildConfigSchema, GenerateOptionsSchema } from './types.js';

// ---------------------------------------------------------------------------
// Dockerfile Generation
// ---------------------------------------------------------------------------

/**
 * Generates a production-ready Dockerfile from configuration.
 */
export function generateDockerfile(config: Partial<DockerBuildConfig> = {}): string {
  const parsed = DockerBuildConfigSchema.parse(config);
  const lines: string[] = [];

  lines.push('# Auto-generated by @dcyfr/ai-docker');
  lines.push(`# Generated: ${new Date().toISOString()}`);
  lines.push('');

  if (parsed.multiStage) {
    // Stage 1: Dependencies
    lines.push('# Stage 1: Dependencies');
    lines.push(`FROM node:${parsed.nodeVersion} AS deps`);
    lines.push(`WORKDIR ${parsed.workdir}`);
    if (parsed.nativeDeps) {
      lines.push('RUN apk add --no-cache python3 make g++');
    }
    lines.push('COPY package.json package-lock.json* ./');
    lines.push('RUN npm ci --omit=dev && npm cache clean --force');
    lines.push('');

    // Stage 2: Build
    lines.push('# Stage 2: Build');
    lines.push(`FROM node:${parsed.nodeVersion} AS build`);
    lines.push(`WORKDIR ${parsed.workdir}`);
    lines.push('COPY package.json package-lock.json* ./');
    lines.push('RUN npm ci && npm cache clean --force');
    lines.push('COPY tsconfig.json ./');
    lines.push('COPY src/ ./src/');
    lines.push('RUN npm run build');
    lines.push('');

    // Stage 3: Production
    lines.push('# Stage 3: Production');
    lines.push(`FROM node:${parsed.nodeVersion} AS production`);
  } else {
    lines.push(`FROM node:${parsed.nodeVersion}`);
  }

  // Labels
  for (const [key, value] of Object.entries(parsed.labels)) {
    lines.push(`LABEL ${key}="${value}"`);
  }

  if (parsed.nonRoot) {
    lines.push('RUN addgroup --system --gid 1001 nodejs && \\');
    lines.push('    adduser --system --uid 1001 dcyfr');
  }

  lines.push(`WORKDIR ${parsed.workdir}`);

  if (parsed.nonRoot) {
    lines.push(`RUN chown dcyfr:nodejs ${parsed.workdir}`);
  }

  if (parsed.multiStage) {
    const ownership = parsed.nonRoot ? '--chown=dcyfr:nodejs ' : '';
    lines.push(`COPY --from=deps ${ownership}${parsed.workdir}/node_modules ./node_modules`);
    lines.push(`COPY --from=build ${ownership}${parsed.workdir}/dist ./dist`);
    lines.push(`COPY --from=build ${ownership}${parsed.workdir}/package.json ./`);
  } else {
    lines.push('COPY package.json package-lock.json* ./');
    lines.push('RUN npm ci --omit=dev && npm cache clean --force');
    lines.push('COPY . .');
  }

  if (parsed.healthCheck) {
    lines.push('');
    lines.push(`HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\`);
    lines.push(`  CMD wget --no-verbose --tries=1 --spider http://localhost:${parsed.port}/health || exit 1`);
  }

  if (parsed.nonRoot) {
    lines.push('');
    lines.push('USER dcyfr');
  }

  lines.push('');
  lines.push(`EXPOSE ${parsed.port}`);
  lines.push('ENV NODE_ENV=production');
  lines.push('CMD ["node", "dist/index.js"]');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Docker Compose Generation
// ---------------------------------------------------------------------------

/**
 * Generates a docker-compose.yml configuration from options.
 */
export function generateCompose(config: ComposeConfig): string {
  const lines: string[] = [];

  lines.push(`# Auto-generated by @dcyfr/ai-docker`);
  lines.push(`# Project: ${config.projectName}`);
  lines.push('');
  lines.push('services:');

  for (const service of config.services) {
    lines.push(`  ${service.name}:`);

    if (service.image) {
      lines.push(`    image: ${service.image}`);
    }

    if (service.build) {
      lines.push('    build:');
      lines.push(`      context: ${service.build.context}`);
      lines.push(`      dockerfile: ${service.build.dockerfile}`);
    }

    if (service.ports.length > 0) {
      lines.push('    ports:');
      for (const port of service.ports) {
        lines.push(`      - "${port}"`);
      }
    }

    if (Object.keys(service.environment).length > 0) {
      lines.push('    environment:');
      for (const [key, value] of Object.entries(service.environment)) {
        lines.push(`      - ${key}=${value}`);
      }
    }

    if (service.volumes.length > 0) {
      lines.push('    volumes:');
      for (const vol of service.volumes) {
        lines.push(`      - ${vol}`);
      }
    }

    if (service.dependsOn.length > 0) {
      lines.push('    depends_on:');
      for (const dep of service.dependsOn) {
        lines.push(`      ${dep}:`);
        lines.push('        condition: service_healthy');
      }
    }

    if (service.healthCheck) {
      lines.push('    healthcheck:');
      lines.push(`      test: ${service.healthCheck}`);
      lines.push('      interval: 10s');
      lines.push('      timeout: 5s');
      lines.push('      retries: 5');
    }

    lines.push(`    restart: ${service.restart}`);
    lines.push(`    networks:`);
    lines.push(`      - ${config.network}`);
    lines.push('');
  }

  if (config.volumes.length > 0) {
    lines.push('volumes:');
    for (const vol of config.volumes) {
      lines.push(`  ${vol}:`);
      lines.push('    driver: local');
    }
    lines.push('');
  }

  lines.push('networks:');
  lines.push(`  ${config.network}:`);
  lines.push('    driver: bridge');
  lines.push('');

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// Full Project Generation
// ---------------------------------------------------------------------------

/**
 * Generates a complete Docker setup based on application options.
 * Returns an object mapping filenames to their generated content.
 */
export function generateProject(
  options: Partial<GenerateOptions> = {},
): Record<string, string> {
  const opts = GenerateOptionsSchema.parse(options);
  const files: Record<string, string> = {};

  // Generate Dockerfile
  const dockerConfig: Partial<DockerBuildConfig> = {
    port: 3000,
    multiStage: true,
    nonRoot: true,
    healthCheck: true,
    nativeDeps: opts.database !== 'none',
  };

  if (opts.target === 'production' || opts.target === 'both') {
    files['Dockerfile'] = generateDockerfile(dockerConfig);
  }

  if (opts.target === 'development' || opts.target === 'both') {
    files['Dockerfile.dev'] = generateDevDockerfile();
  }

  // Generate docker-compose
  const services = buildServices(opts);
  const volumes = buildVolumes(opts);

  if (opts.target === 'development' || opts.target === 'both') {
    files['docker-compose.yml'] = generateCompose({
      projectName: 'dcyfr-app',
      services: services.dev,
      volumes: volumes.dev,
      network: 'dcyfr-network',
    });
  }

  if (opts.target === 'production' || opts.target === 'both') {
    files['docker-compose.prod.yml'] = generateCompose({
      projectName: 'dcyfr-app',
      services: services.prod,
      volumes: volumes.prod,
      network: 'dcyfr-network',
    });
  }

  // Generate .dockerignore
  files['.dockerignore'] = generateDockerignore();

  return files;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function generateDevDockerfile(): string {
  return [
    '# Auto-generated by @dcyfr/ai-docker (Development)',
    `# Generated: ${new Date().toISOString()}`,
    '',
    'FROM node:22-alpine',
    'WORKDIR /app',
    'RUN apk add --no-cache curl',
    'COPY package.json package-lock.json* ./',
    'RUN npm ci && npm cache clean --force',
    'COPY . .',
    'EXPOSE ${PORT:-3000}',
    'EXPOSE 9229',
    'ENV NODE_ENV=development',
    'CMD ["npm", "run", "dev"]',
    '',
  ].join('\n');
}

function generateDockerignore(): string {
  return [
    'node_modules',
    'dist',
    '.git',
    '.env',
    '.env.local',
    '*.md',
    'tests',
    'coverage',
    'Dockerfile*',
    'docker-compose*.yml',
    '.dockerignore',
    '',
  ].join('\n');
}

interface ServiceSets {
  dev: Array<import('./types.js').ComposeService>;
  prod: Array<import('./types.js').ComposeService>;
}

interface VolumeSets {
  dev: string[];
  prod: string[];
}

function buildServices(opts: GenerateOptions): ServiceSets {
  const devServices: Array<import('./types.js').ComposeService> = [];
  const prodServices: Array<import('./types.js').ComposeService> = [];

  const dependsOn: string[] = [];

  if (opts.database === 'postgres') {
    dependsOn.push('db');

    devServices.push({
      name: 'db',
      image: 'postgres:16-alpine',
      ports: ['5432:5432'],
      environment: {
        POSTGRES_USER: 'postgres',
        POSTGRES_PASSWORD: 'postgres',
        POSTGRES_DB: 'app',
      },
      volumes: ['pgdata:/var/lib/postgresql/data'],
      dependsOn: [],
      healthCheck: '["CMD-SHELL", "pg_isready -U postgres"]',
      restart: 'unless-stopped',
    });

    prodServices.push({
      name: 'db',
      image: 'postgres:16-alpine',
      ports: [],
      environment: {
        POSTGRES_USER: '${DB_USER:-dcyfr}',
        POSTGRES_PASSWORD: '${DB_PASSWORD}',
        POSTGRES_DB: '${DB_NAME:-app}',
      },
      volumes: ['pgdata-prod:/var/lib/postgresql/data'],
      dependsOn: [],
      healthCheck: '["CMD-SHELL", "pg_isready -U ${DB_USER:-dcyfr}"]',
      restart: 'always',
    });
  }

  if (opts.database === 'mysql') {
    dependsOn.push('db');

    devServices.push({
      name: 'db',
      image: 'mysql:8.0',
      ports: ['3306:3306'],
      environment: {
        MYSQL_ROOT_PASSWORD: 'root',
        MYSQL_DATABASE: 'app',
        MYSQL_USER: 'mysql',
        MYSQL_PASSWORD: 'mysql',
      },
      volumes: ['mysqldata:/var/lib/mysql'],
      dependsOn: [],
      healthCheck: '["CMD", "mysqladmin", "ping", "-h", "localhost"]',
      restart: 'unless-stopped',
    });

    prodServices.push({
      name: 'db',
      image: 'mysql:8.0',
      ports: [],
      environment: {
        MYSQL_ROOT_PASSWORD: '${DB_ROOT_PASSWORD}',
        MYSQL_DATABASE: '${DB_NAME:-app}',
        MYSQL_USER: '${DB_USER:-dcyfr}',
        MYSQL_PASSWORD: '${DB_PASSWORD}',
      },
      volumes: ['mysqldata-prod:/var/lib/mysql'],
      dependsOn: [],
      healthCheck: '["CMD", "mysqladmin", "ping", "-h", "localhost"]',
      restart: 'always',
    });
  }

  if (opts.redis) {
    dependsOn.push('redis');

    devServices.push({
      name: 'redis',
      image: 'redis:7-alpine',
      ports: ['6379:6379'],
      environment: {},
      volumes: ['redisdata:/data'],
      dependsOn: [],
      healthCheck: '["CMD", "redis-cli", "ping"]',
      restart: 'unless-stopped',
    });

    prodServices.push({
      name: 'redis',
      image: 'redis:7-alpine',
      ports: [],
      environment: {},
      volumes: ['redisdata-prod:/data'],
      dependsOn: [],
      healthCheck: '["CMD", "redis-cli", "ping"]',
      restart: 'always',
    });
  }

  // App service
  devServices.unshift({
    name: 'app',
    build: { context: '.', dockerfile: 'Dockerfile.dev' },
    ports: ['${PORT:-3000}:${PORT:-3000}', '9229:9229'],
    environment: { NODE_ENV: 'development' },
    volumes: ['.:/app', '/app/node_modules'],
    dependsOn,
    restart: 'unless-stopped',
  });

  prodServices.unshift({
    name: 'app',
    build: { context: '.', dockerfile: 'Dockerfile' },
    ports: ['${PORT:-3000}:${PORT:-3000}'],
    environment: { NODE_ENV: 'production' },
    volumes: [],
    dependsOn,
    restart: 'always',
  });

  return { dev: devServices, prod: prodServices };
}

function buildVolumes(opts: GenerateOptions): VolumeSets {
  const dev: string[] = [];
  const prod: string[] = [];

  if (opts.database === 'postgres') {
    dev.push('pgdata');
    prod.push('pgdata-prod');
  }

  if (opts.database === 'mysql') {
    dev.push('mysqldata');
    prod.push('mysqldata-prod');
  }

  if (opts.redis) {
    dev.push('redisdata');
    prod.push('redisdata-prod');
  }

  return { dev, prod };
}
